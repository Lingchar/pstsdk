<div class="wikidoc">This page contains a quick overview of the LTP layer. For a more in depth description of what is contained, see the LTP module in the documentation distributed with the library. 
<h1>LTP Layer Overview</h1>
The LTP Layer contains implementations of all of the data structures defined in <span class="codeInline">[MS-PST]</span> 2.3. These data structures are built on top of the <span class="codeInline">node</span> abstraction exposed by the <a href="https://pstsdk.codeplex.com/wikipage?title=ndb&referringTitle=ltp">ndb</a>.<br />
<ol><li><a href="#Getting Started">Getting Started</a></li>
<li><a href="#Coming up from the NDB">Coming up from the NDB</a>
<ol><li><a href="#Heaps">Heaps</a></li>
<li><a href="#BTree-on-Heaps">BTree-on-Heaps</a></li></ol></li>
<li><a href="#Working with property objects">Working with property objects</a></li>
<li><a href="#Property Bags">Property Bags</a></li>
<li><a href="#Tables">Tables</a></li></ol>
<br /><a name="Getting Started"></a>
<h2>Getting Started</h2>Unlike working with the <a href="https://pstsdk.codeplex.com/wikipage?title=pst&referringTitle=ltp">pst</a> or <a href="https://pstsdk.codeplex.com/wikipage?title=ndb&referringTitle=ltp">ndb</a>, the LTP layer isn&#39;t free standing - there is no way to open some abstraction of a database in the LTP layer. So, in order to operate at this level, you are coming either from the PST layer where you &quot;unwrapped&quot; an object, or coming up from the NDB layer where you are interpreting nodes in a certain fashion. I&#39;ll assume you&#39;re doing the former, but we&#39;ll briefly go over the building blocks of the LTP first.<br /><br />Similar to other layers; you can either include the rolled up ltp header or the individual headers,<br /><br /><pre>
#include &quot;ltp.h&quot; // includes all other ltp layer headers
</pre><br /><a name="Coming up from the NDB"></a>
<h2>Coming up from the NDB</h2>If you&#39;re coming up from the <a href="https://pstsdk.codeplex.com/wikipage?title=ndb&referringTitle=ltp">ndb</a>, we&#39;ll assume you have both a <span class="codeInline">node</span> object and a <span class="codeInline">shared_db_ptr</span> - at least, you can get one from the node. So what can we do to interpret a node at a higher level than just a flat stream of bytes? That is where the <span class="codeInline">heap</span> comes in.<br /><a name="Heaps"></a>
<h3>Heaps</h3>The first thing to know about a <span class="codeInline">heap</span> is that it completely controls a node. We say a given <span class="codeInline">node</span> <i>is a</i> <span class="codeInline">heap</span>, <b>not</b> a <span class="codeInline">heap</span> <i>is in</i> a <span class="codeInline">node</span>. You can not have two <span class="codeInline">heap</span> objects in a node. You can&#39;t have anything in a <span class="codeInline">node</span> which is a <span class="codeInline">heap</span> without the heap knowing about it, or you&#39;re risking really confusing someone. Think of a <span class="codeInline">heap</span> as a higher level interpretation of the entirety of a <span class="codeInline">node</span> - but not that <span class="codeInline">node</span> objects subnodes.<br /><br />In general terms, almost all nodes in the NBT are organized as heaps. All message and folder nodes are. Certain internal queue nodes are not. The reverse is true for subnodes; most subnodes are not heaps but instead just overflow allocations which could not fit in the heap proper. However some subnodes are; such as attachment subnodes. In general, you just kind of have to &quot;know&quot; given the context of where the node is located, what its node type is, and who told you about it in order to be able to interpret the node properly.<br /><br />The purpose of a <span class="codeInline">heap</span> is to subdivide a <span class="codeInline">node</span> into smaller allocations. A client can perform these operations on a <span class="codeInline">heap</span> in the PST:
<ul><li>Allocate space and get back an allocation id. Max 3.8k in size.</li>
<li>Read/write to an allocation id</li>
<li>Free an allocation id</li>
<li>Store a special allocation id called the &quot;root&quot; allocation</li>
<li>Retrieve the &quot;root&quot; allocation id of a heap</li></ul>
<br />Obviously since this is a read only library, we&#39;re limited to only doing half of the above.<br /><br />Internally, a <span class="codeInline">heap</span> has very special and deep knowledge about the implementation of a <span class="codeInline">node</span>. That is to say, it is aware that a node&#39;s data is actually organized in blocks of 8k in size, potentially with an <span class="codeInline">extended_block</span> used to chain together multiple 8k <span class="codeInline">external_block</span> objects together to expose a logically larger area. The <span class="codeInline">heap</span> keeps book keeping information both at the start and end of each <span class="codeInline">external_block</span> in a node, keeping track of what space is allocated, etc. The heap allocation id&#39;s it gives out actually are a bit field which indicates which page (..external block) the allocation is on and the index into an allocation array kept at the end of that page, which gives the true offset of the allocation.<br /><br />So that is the background information. To use a <span class="codeInline">heap</span> object is pretty simple; you construct one with a <span class="codeInline">node</span> you are wrapping or interpreting as a heap (this node will be copied unless you specify the alias constructor); then call various methods on it.<br /><br /><pre>
node n = ....;
heap myheap(n);

heap_id root_allocation = myheap.get_root_id(); 
vector&lt;byte&gt; data = myheap.read(root_allocation); // hopefully you know what these bytes are
</pre><br />You might be asking, &quot;How do I know what the root allocation is, or points to?&quot;. Well, the first point is - the heap doesn&#39;t know, either. It just stores off the root allocation id for the client and returns it when asked. The person who does know is the <i>creator</i> of the heap. And you should have enough context as to who the creator is, based on the node type, where you found the node, etc.<br /><a name="BTree-on-Heaps"></a>
<h3>BTree-on-Heaps</h3>The <span class="codeInline">heap</span> has one other special power; open a BTree-on-Heap object from within itself. A BTree-on-Heap (BTH) models the BTree hierarchy, just like the NBT/BBT. What it actually is a &quot;header&quot; allocation out of the heap which gives some information such as the key and value size, as well as the &quot;root allocation&quot; which is another allocation out of the heap which represents the root of the Tree structure. In reality, because heap allocations can be pretty large (3.8k), and the amount of data stored in a BTH is pretty small (a few dozen entries) it is pretty common for the &quot;root allocation&quot; to be a single leaf BTH node.<br /><br />You may be familiar with working with BTree Hierarchy&#39;s by now. The idea is you get a pointer to the &quot;root&quot; node, and call lookup or iteration functions, and each node will know how to defer to child nodes if appropriate or do the lookup on itself if it is a leaf node.<br /><br />Note that a BTH has no idea what data is stored in either the key or the value. It just blindly stores the pairs for interpretation by other structures.<br /><br />Also note that a BTH is not to a <span class="codeInline">heap</span> what a <span class="codeInline">heap</span> is to a <span class="codeInline">node</span> - we say that a BTH is <i>inside of</i> a <span class="codeInline">heap</span>. In reality a BTH is a collection of seperate but related <span class="codeInline">heap</span> allocations. You could have multiple unique BTH&#39;s in a <span class="codeInline">heap</span>, although in practice that isn&#39;t useful.<br /><br /><pre>
unique_ptr&lt;bth_node&lt;prop_id, disk::prop_entry&gt;&gt; bth_root_node = myheap.open_bth(root_allocation);
disk::prop_entry foo = bth_root_node-&gt;lookup(0x3001);
</pre><br />Generally, you will not work directly with a BTH object, but rather use other LTP objects which use them.<br /><a name="Working with property objects"></a>
<h2>Working with property objects</h2>Before we get into the specific LTP objects built on top of a <span class="codeInline">heap</span> and a <span class="codeInline">BTH</span>, we should discuss what a property object is. A property object, or the <span class="codeInline">const_property_object</span> base class, is both a base class and an interface for accessing &quot;properties&quot; on an &quot;object&quot;. There are two implementations we&#39;ll discuss shortly - the <span class="codeInline">property_bag</span> and <span class="codeInline">const_table_row</span>. But for now, a <span class="codeInline">const_property_object</span> is any object you can enumerate the properties of and read those properties.<br /><br />The iterface is simple; you call <span class="codeInline">const_property_object::read_prop&lt;T&gt;(prop_id)</span> to read a given property (there is also an array version for multivalued properties - as well as varients for opening a property as a stream). You choose how to interpret the property (you supply the &quot;T&quot;). If you don&#39;t know, you can call <span class="codeInline">const_property_object::get_prop_type(prop_id)</span>. You can also call <span class="codeInline">const_property_object::get_prop_list</span> to read all properties on the object.<br /><br />The following code fragment iterates over all properties on a given property object, and does something with all of the string types:<br /><br /><pre>
const_property_object&amp; obj = ...;
vector&lt;prop_id&gt; prop_list = obj.get_prop_list();

for(vector&lt;prop_id&gt;::iterator iter = prop_list.begin(); iter != prop_list.end(); ++iter)
{
    if(obj.get_prop_type(*iter) == prop_type_wstring)
    {
        wstring prop_val = obj.read_prop&lt;wstring&gt;(*iter);
        // do something with prop_val
    }
}
</pre><br />There are methods to check to see if a property exists as well. You can also open any variable length property as a stream, and do something special with it. This is useful for large properties you may not want to load in memory all at once.<br /><br /><pre>
if(obj.prop_exists(0x1000))
{
    prop_stream body(obj.open_prop_stream(0x1000));
    // do stream type stuff with body
}
</pre><br /><a name="Property Bags"></a>
<h2>Property Bags</h2>A <span class="codeInline">property_bag</span> is the implementation of what <span class="codeInline">[MS-PST]</span> calls a Property Context or PC. On disk, it is a heap (which is a node), which has a single BTH stored in it, the root of which stored as the root allocation of the heap. The key of the BTH is the prop_id, and the value is something called a <span class="codeInline">disk::prop_entry</span>. The prop entry gives you the type of the property as well as where it is located - its storage is defined by the type and the allocation id. It could be inline, or it could be a heap allocation, or it could be a subnode.<br /><br />All of this logic is encapsulated in the <span class="codeInline">property_bag</span>. You&#39;ll be most familiar with this class because this is what you get back when you &quot;unwrap&quot; a <a href="https://pstsdk.codeplex.com/wikipage?title=pst&referringTitle=ltp">pst</a> layer object. For example, if you want to read some property off of a <span class="codeInline">message</span> not directly exposed, such as PidTagCreationTime:<br /><br /><pre>
message m = ...;
property_bag&amp; bag = m.get_property_bag(); // unwrap down to the LTP
time_t creation_time = bag.read_prop&lt;time_t&gt;(0x3007);
... // gloat about knowing the creation time of this message
</pre><br />There is not much else to <span class="codeInline">property_bag</span> besides its <span class="codeInline">const_property_object</span> implementation except perhaps its ability to unwrap down to the <span class="codeInline">node</span> itself, if needed.<br /><a name="Tables"></a>
<h2>Tables</h2>A <span class="codeInline">table</span> is the implementation of what <span class="codeInline">[MS-PST]</span> calls a Table Context or TC. It is a heap (which is a node) which has a &quot;table header&quot; stored as the root allocation. The table header gives information about the table such as the number and type of columns, the root of a BTH which maps row identifiers (usually node_ids) to row offsets, and the row matrix allocation. The row matrix allocation is either a heap allocation itself (not usually, only for very tiny tables) or a subnode. <br /><br />The table context is the most complicated structure in the PST (narrowly beating out the <span class="codeInline">name_id_map</span> structure, not discussed here). Fortunately, all of this logic is encapsulated in an easy to use <span class="codeInline">table</span> class. You will probably be familiar with the class because this is what you get back when you &quot;unwrap&quot; a <a href="https://pstsdk.codeplex.com/wikipage?title=pst&referringTitle=ltp">pst</a> <span class="codeInline">folder</span> object to its contents table (messages in the folder) or hierarchy table (subfolders).<br /><br />A <span class="codeInline">table</span> allows you to access its rows. A row is basically a <span class="codeInline">const_property_object</span> giving the properties of that row. It&#39;s that simple. The easiest way to access the rows is by using operator[]:<br /><br /><pre>
table&amp; tab = ...;
for(int i = 0; i &lt; tab.size(); ++i)
{
    const_table_row row = tab[i];
    ... // party on row
}
</pre><br />Iterator style access (begin/end, etc) is also supported.<br /><br />The one other capability the table provides is fast lookup by <span class="codeInline">row_id</span>. The exact <span class="codeInline">row_id</span> type varies by table, but for contents tables and hierarchy tables it is the <span class="codeInline">node_id</span> of the object. So if you know the <span class="codeInline">node_id</span>, you can do this for example:<br /><br /><pre>
node_id mysubfolder = ...; // I know this somehow
ulong row = tab.lookup_row(mysubfolder);
wstring displayname = tab[row].read_prop&lt;wstring&gt;(0x3001);
</pre><br />Under the hood this is a BTH lookup, into a BTH maintained for this exact purpose.</div><div class="ClearBoth"></div>